# 编辑距离问题

- **状态转移方程：** 

  $dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + (s1[i] != b[j])) $
- **问题背景**
给定字符串s1, s2, 允许对字符串s1进行增加，删除，更新操作，一次操作只能变动一个字符，问最少需要多少次操作可以让s1变成s2？
- **分析**
$dp[i][j]$ 含义：字符串s1的长度为1-i的部分，变成字符串b长度为1-j的部分至少需要的操作次数。
初始化：$dp[i][0] = i; dp[0][j] = j;$
划分4个不同状态：
    1. 最后一次更新操作，是删除了s1的最后一个字符：题目考虑的是至少需要的次数，因此不可能出现的情况是：我自己添加了一个字符，然后又把它删除掉，因此被删除的字符绝对是原本就存在于s1的字符。因此，这种情况下s1最后一个字符是没用的。因此可知此时$dp[i][j] = dp[i - 1][j] + 1 $.
    2. 最后一次更新操作，是在s1后面加上一个新字符：通过刚刚分析容易知道$dp[i][j] = dp[i][j - 1] + 1 $.
    3. 最后一次更新操作，是对s1的最后一个字符进行替换：也就是说前1~i-1和1~j-1是一样的。因此$dp[i][j] = dp[i - 1][j - 1] + 1 $.
    4. 最后一次更新操作和s1最后一个字符无关：**这说明最后一个字符已经相等**，我们只需要看看1~i - 1和1~j - 1是不是一样即可！因此$dp[i][j] = dp[i - 1][j - 1] $.  
   
综上所述可得状态转移方程。
```
int fun(string sa, string sb) {
    memset(dp, 0, sizeof dp);
    int l1 = sa.length(), l2 = sb.length();
    for (int i = 1; i <= l1; i++) dp[i][0] = i;
    for (int j = 1; j <= l2; j++) dp[0][j] = j;

    for (int i = 1; i <= l1; i++) {
        for (int j = 1; j <= l2; j++) {
            dp[i][j] = min(min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + (sa[i] != sb[j]));
        }
    }
    return dp[l1][l2];
}
```