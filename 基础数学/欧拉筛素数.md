# 欧拉筛
- 在1~n里面筛选出素数的数量，也可以选出素数的集合，这里用$prime[ ]$表示。
- 还需要一个bool数组st来判断合数，为true的分量就是合数。
- 算法开始，i从2到n开始循环。循环开始时，判断st[i]是否是false，如果是，那就说明i是素数，则$prime[cnt++]$ = i. 这时候，根据prime里面的所有元素来生成未来不可能再是素数的数，也就是未来的合数。这里由于i恰好是从2开始的，**因此i还可以有另一个作用：充当乘数**。
- 对prime里面现在存放的所有素数，都乘上i，然后使得$st[prime[j] * i] = true$即可，那么这些可以生成的合数就被选出来了。
- 但是，例如12可以是3 * 4 也可以是2 * 6，每一次内层循环，有可能做一些没必要的工作。这个例子里，i = 4时，把3 * 4选出来使得12被标记；而i = 6时又把2 * 6选出来使得12被标记。实际上6就是3的倍数，它也可以被分解为6 = 2 * 3，那么每一次标记完成之后，**做一个判断：i % prime[j] == 0 (也即i是当前遍历到的素数的倍数)** 就break。这里12 = 6 * 2 = 3 * 2 * 2 = 4 * 3，所以就不需要再弄了。
  - 另一个思路：**每个合数只被其最小的质因数筛去一次。**
  - 由于从小到大遍历prime，所以$i \% prime[j] = 0$就说明$prime[j]$是$i$的最小质因子。由于 **st[prime[j] * i] = true**语句出现在break的上方，因此先执行，也即出现$i \% prime[j] = 0$情况时就把$i * prime[j]$放进去，这时候$prime[j]$也是$i * prime[j]$的最小质因子，之后break。
  - 如果继续进行，那么我们就把$prime[j+1]*i $这个数筛掉了,虽然这个数也是合数。但是我们筛掉它的时候并不是用它的最小质因数筛掉的，而是利用 $prime[j+1] 和 i$ 把它删掉的！
- 最后只需要输出cnt就可以得到数量，查看prime集合即可筛选合数。时间复杂度O(N).
```
int cnt, prime[1000005];
bool st[1000005]; //合数判断

void get_prime(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) prime[cnt++] = i;

        for (int j = 0; prime[j] * i <= n && j < cnt; j++) {
            st[prime[j] * i] = true;
            if (i % prime[j] == 0) break;
        }
    }
}
```